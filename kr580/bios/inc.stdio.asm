; ----------------------------------------------------------------------
; Пропечатка в буфер integer 16 битного
; Вход:  DE-входящие данные
; Выход: DE-указатель на полученную строку
; ----------------------------------------------------------------------

; Переменные
itoa_dt:    defb 6,5,5,3,5,0

; Процедура
itoa:       push    bc
            push    hl
            ld      hl, itoa_dt+4       ; Последний символ
            ld      bc, 10
L1:         push    hl
            call    div16u              ; Разделить число на 10
            ld      a, l                ; Записать остаток в A
            add     a, '0'
            pop     hl
            ld      (hl), a             ; Запись числа '0'..'9' ASCII
            dec     hl
            ld      a, d
            or      e
            jr      nz, L1              ; Повторять пока не будет 0
            inc     hl                  ; Восстановить указатель
            ex      de, hl              ; Поместить HL -> DE
            pop     hl
            pop     bc
            ret

; ----------------------------------------------------------------------
; Чтение нажатия символа с ожиданием и выдача его в A
; ----------------------------------------------------------------------
getch:      push    bc
            push    hl

            ld      hl, keyb_spec
            in      a, ($ff)
            ld      b, a
getchl:     in      a, ($ff)        ; Ждать переключения клавиши
            cp      b
            jr      z, getchl
            ld      b, a

            ; Обработка нажатия клавиш
            in      a, ($fe)        ; Полученный символ
            cp      $11             ; Левый SHIFT нажат
            jr      nz, $+6
            set     0, (hl)
            jr      getchl
            cp      $11 + $80       ; Левый SHIFT отпущен
            jr      nz, $+6
            res     0, (hl)
            jr      getchl
            cp      $80
            jr      nc, getchl      ; Отпущенная клавиша не интересует

            ; Если SHIFT отпущен => AZ -> az
            bit     0, (hl)
            jr      nz, getch1
            cp      'A'
            jr      c, getch1
            cp      'Z'+1
            jr      nc, getch1
            add     'a'-'A'
getch1:
            ; ...
            pop     hl
            pop     bc
            ret
